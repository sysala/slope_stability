function [x, res_hist] = dminres(A, rhs, maxiter, tol, M, x0, W, verbose)
%MINRES Minimum Residual Method for symmetric linear systems with optional deflation.
%
%   [x, res_hist] = minres(A, rhs, maxiter, tol, M, x0, W, verbose)
%
%   Solves the symmetric linear system A*x = rhs using the Minimum
%   Residual (MINRES) method. Suitable for symmetric, possibly indefinite systems.
%
%   Inputs:
%       A       - Function handle or matrix providing the matrix-vector
%                 product A*x. Must represent a symmetric operator.
%       rhs     - Right-hand side vector b.
%       maxiter - Maximum number of iterations allowed.
%       tol     - Tolerance for the relative residual norm (norm(b-A*x)/norm(b)).
%       M       - (Optional) Function handle or matrix for preconditioning (M\x).
%                 Defaults to identity. Must be symmetric positive definite.
%       x0      - (Optional) Initial guess for x. Defaults to zero vector,
%                 unless W is provided, in which case a projected initial
%                 guess is used and x0 is ignored.
%       W       - (Optional) Deflation subspace basis (matrix whose columns
%                 span the subspace). Assumed to be A-orthonormal
%                 (W'*A*W = I), though only W'*A is used in the projection.
%                 If provided, the search is restricted to the A-orthogonal
%                 complement of span(W).
%       verbose - (Optional) Boolean flag. If true, prints convergence/debug
%                 information. Defaults to false.
%
%   Outputs:
%       x        - Computed approximate solution vector.
%       res_hist - Vector containing the estimated relative residual norm
%                  at each iteration (||M^{-1/2}*r_k|| / ||M^{-1/2}*r_0||).
%                  The first element is the norm of the initial residual.
%
%   Algorithm: MINRES minimizes norm(b - A*x_k) using the Lanczos process
%   and QR factorization via Givens rotations. If W is provided, applies
%   projection steps to keep the search directions A-orthogonal to W.

    n = length(rhs);

    % --- Handle optional inputs ---
    if nargin < 8 || isempty(verbose)
        verbose = false; % Default: no verbose output
    end
    if nargin < 7
        W = []; % Default: no deflation
    end
    if nargin < 5 || isempty(M)
        M = @(r) r; % Default: Identity preconditioner
    end

    % --- Deflation Setup (overrides x0 if W is given) ---
    if isempty(W)
        Proj_fct = @(vec) vec; % Identity projection
        if nargin < 6 || isempty(x0)
            x = zeros(n, 1); % Default initial guess: zero vector
        else
            x = x0;          % Use provided initial guess
        end
    else
        if verbose
            fprintf('MINRES: Using deflation subspace W.\n');
        end
        % Projector to make vectors A-orthogonal to span(W)
        % P(v) = v - W * inv(W'*A*W) * (W'*A*v)
        % Since W is assumed A-orthonormal (W'*A*W = I), this simplifies:
        Proj_fct = @(vec) vec - W * (W' * (A(vec)));

        % Initial guess based on coarse projection (overrides x0)
        % User formula: Q_coarse_solve(b) = W * (W'*b)
        x = W * (W' * rhs);
        if verbose
             fprintf('MINRES: Using projected initial guess based on W.\n');
        end
    end

    % --- Initialization ---
    r = rhs - A(x);       % Initial residual r_0 = b - A*x_0
    % Note: Initial residual is *not* projected by Proj_fct here.
    % Deflation affects the *search directions* generated by Lanczos.

    y = M(r);             % Apply preconditioner: y_0 = M \ r_0

    beta1 = sqrt(dot(r, y)); % beta_1 = ||r_0||_M
    res_norm_est = beta1; % Initial estimated M-norm of residual
    res_init = beta1;     % Store initial M-norm for relative stopping criterion
    res_hist = zeros(maxiter + 1, 1); % Preallocate residual history
    res_hist(1) = 1.0;    % Initial relative residual is 1

    if beta1 < tol % Check if initial guess is already good enough
        if verbose
            fprintf('MINRES: Initial guess meets tolerance (||r_0||_M = %e).\n', beta1);
        end
        res_hist = res_hist(1);
        return;
    end

    v_old = zeros(n, 1);  % v_0 = 0
    v = y / beta1;        % v_1 = y_0 / beta_1 (M-normalized)
    beta = beta1;         % beta_k (current beta)

    % Lanczos/QR variables
    c_old = -1.0;         % c_{k-1}
    s_old =  0.0;         % s_{k-1}
    eta   = beta1;        % Corresponds to the rotated RHS [beta1; 0; ...]

    % Solution update variables (based on Paige & Saunders W matrix)
    w = zeros(n, 1);      % w_{k-1} (scaled Lanczos basis vector)
    w_prev = zeros(n, 1); % w_{k-2}

    % --- Main MINRES Iteration Loop ---
    for k = 1:maxiter
        % --- Lanczos Step ---
        Av = A(v);           % p_k = A * v_k
        alpha = dot(v, Av);  % alpha_k = v_k' * A * v_k (or v_k' * M * A * v_k if M=I)

        % Orthogonalize Av against v and v_old (raw next Lanczos vector)
        Av = Av - alpha * v - beta * v_old;

        % --- Apply Deflation Projection ---
        Av_proj = Proj_fct(Av); % Project result to be A-orthogonal to W

        % --- Apply Preconditioner ---
        y = M(Av_proj);      % y_k = M \ (P(A*v_k - alpha_k*v_k - beta_k*v_{k-1}))

        % --- Compute next beta ---
        % Note: Need dot(Av_proj, y) which is dot(Av_proj, M\Av_proj) = || Av_proj ||_M^2
        beta_next = sqrt(dot(Av_proj, y)); % beta_{k+1} = || P(...) ||_M

        % --- Apply previous Givens rotation Q_{k-1} ---
        delta_k     = c_old * beta + s_old * alpha;
        gamma_prime = -s_old * beta + c_old * alpha;

        % --- Compute and apply current Givens rotation Q_k ---
        [c_new, s_new, gamma_k] = givens_rot(gamma_prime, beta_next);

        % --- Update RHS vector [eta; 0] ---
        eta_next = s_new * eta;       % Residual norm estimate component
        eta      = c_new * eta;       % Solution update component (g_k)

        % --- Update solution vector x ---
        % w_k = (v_k - delta_k * w_{k-1} - gamma_prime * w_{k-2}) / gamma_k
        if abs(gamma_k) < eps % Avoid division by zero if gamma_k is tiny
            if verbose
                fprintf('MINRES: Warning: gamma_k is close to zero (%e) at iteration %d.\n', gamma_k, k);
            end
            % If gamma_k is zero, suggests breakdown or stagnation.
            % The update formula becomes unstable. Might indicate convergence
            % or issues with the matrix/preconditioner/projection.
            % Proceed cautiously or stop if residual also small.
            w_curr = zeros(n,1); % Avoid NaN/Inf, effectively stop contribution from this direction
        else
            w_curr = (v - delta_k * w_prev - gamma_prime * w) / gamma_k;
        end
        x = x + eta * w_curr;

        % --- Update residual norm estimate ---
        res_norm_est = abs(eta_next); % Estimated ||M^{-1/2} r_k||
        res_hist(k + 1) = res_norm_est / res_init; % Store relative residual norm

        % --- Check stopping criterion ---
        if res_norm_est < tol * res_init
            if verbose
                fprintf('MINRES converged at iteration %d with relative residual norm %e\n', k, res_hist(k+1));
            end
            res_hist = res_hist(1:(k + 1)); % Trim history
            return;
        end

        % --- Check for Lanczos breakdown (beta_next ~ 0) ---
        if beta_next < eps % Use machine epsilon or a small number
             if res_norm_est < tol * res_init
                 if verbose
                     fprintf('MINRES: Lanczos breakdown (beta=%e), but tolerance met at iteration %d.\n', beta_next, k);
                 end
                 res_hist = res_hist(1:(k + 1));
                 return;
             else
                 if verbose
                     fprintf('MINRES: Lanczos breakdown (beta=%e) at iteration %d before convergence.\n', beta_next, k);
                 end
                 res_hist = res_hist(1:(k + 1));
                 warning('MINRES:LanczosBreakdown', 'MINRES breakdown, solution may be inaccurate.');
                 return;
             end
        end

        % --- Prepare for next iteration ---
        v_old = v;
        v = y / beta_next;   % v_{k+1} = y_k / beta_{k+1} (M-normalized)
        beta = beta_next;    % Update beta

        c_old = c_new;       % Update Givens parameters
        s_old = s_new;

        w_prev = w;          % Update solution directions
        w = w_curr;

    end % End of main loop

    % --- Max iterations reached ---
    if verbose
        fprintf('MINRES did not converge within %d iterations. Relative residual norm = %e\n', maxiter, res_hist(end));
    end
    res_hist = res_hist(1:(maxiter + 1)); % Return full history

end % End of function minres

% --- Helper function for Givens rotation ---
function [c, s, rho] = givens_rot(a, b)
% Computes parameters for Givens rotation G = [c s; -s c]
% such that G * [a; b] = [rho; 0], where rho = sqrt(a^2 + b^2).
    if b == 0
        c = sign(a); % Handle a=0 case implicitly by rho=0
        s = 0;
        rho = abs(a);
    elseif a == 0
        c = 0;
        s = sign(b);
        rho = abs(b);
    else
        rho = hypot(a, b); % sqrt(a^2 + b^2)
        c = a / rho;
        s = b / rho;
    end
end